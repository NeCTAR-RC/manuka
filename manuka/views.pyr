from datetime import datetime
import functools
import json
import logging
from os import path
from urllib import parse


LOG = logging.getLogger('rcshibboleth.views')

STATIC_FILES = path.join(path.dirname(__file__), "static")

# include the request in each template
template = functools.partial(template, request=request)


class ShibbolethAttrMap(object):
    data = {'persistent-id': 'id',
            'cn': 'cn',
            'displayName': 'fullname',
            'givenName': 'firstname',
            'sn': 'surname',
            'uid': 'uid',
            'mail': 'mail',
            'eppn': 'eppn',
            'l': 'location',
            'description': 'description',
            'o': 'organisation',
            'affiliation': 'affiliation',
            'unscoped-affiliation': 'unscoped-affiliation',
            'assurance': 'assurance',
            'Shib-Identity-Provider': 'idp',
            'shared-token': 'shared_token',
            'homeOrganization': 'homeorganization',
            'homeOrganizationType': 'homeorganizationtype',
            'telephoneNumber': 'telephonenumber',
            'mobileNumber': 'mobilenumber',
            'eduPersonOrcid': 'orcid'}

    @classmethod
    def parse(cls, environ):
        metadata = {}
        for k, v in cls.data.items():
            if environ.get(k):
                if k == "mail":
                    metadata[v] = environ.get(k).lower()
                else:
                    metadata[v] = environ.get(k)
        return metadata

    @classmethod
    def get_attr(cls, name):
        for k, v in cls.data.items():
            if name == v:
                return k


class Whitelist(object):
    """List of URLs that are accepted as return-path values, specified in
    a 'whitelist' section in the config.
    """

    data = []
    initialised = False

    def __init__(self, defaults=None):
        # sjjf: this is a wart resulting from the testing system.
        # If we put the CONFIG['target'] in the __init__ call it's
        # resolved every time a whitelist object is instantiated,
        # including all the tests where we haven't made sure
        # everything is set up appropriately - moving it down here
        # avoids that, allowing the rest of the tests to run without
        # needing lots of futzing around.
        if not defaults:
            defaults = [CONFIG['target']]
        if defaults:
            for url in defaults:
                if url not in Whitelist.data:
                    Whitelist.data.append(url)

        if not Whitelist.initialised:
            self._refresh()
            Whitelist.initialised = True

    def _refresh(self, filename=None):
        source = None
        # default to the configured whitelist
        try:
            source = CONFIG['whitelist']
        except KeyError:
            pass
        # allow a manual override
        if filename:
            source = filename
        # if there's still nothing, we're done
        if not source:
            return
        try:
            with open(source) as whitelist_file:
                for line in whitelist_file:
                    comment = len(line)
                    if "#" in line:
                        comment = line.find("#")
                    stripped = line[:comment].strip()
                    if len(stripped) > 0:
                        if stripped not in Whitelist.data:
                            Whitelist.data.append(stripped)
        except IOError:
            LOG.info("Whitelist file " + CONFIG['whitelist'] + " not found")

    def __contains__(self, key):
        try:
            return key in self.data
        except IndexError:
            return False

    def __repr__(self):
        return "\n".join(self.data)


@route('/static/:filepath')
def static(filepath):
    return static_file(filepath, root=STATIC_FILES)


@route('/account_status', method='GET')
def account_status(db):
    session = request.environ["beaker.session"]
    LOG.debug("The headers are: %s.", request.environ)
    shib_user = db.query(models.User).filter_by(
        persistent_id=session["user_id"]).first()
    data = {"state": shib_user.state}
    return json.dumps(data)


@route('/')
@route('/', method='POST')
def root(db, rpcclient):
    session = request.environ["beaker.session"]
    LOG.debug("The headers are: %s.", request.environ)
    shib_attrs = ShibbolethAttrMap.parse(request.environ)
    LOG.info("The AAF responded with: %s.", shib_attrs)

    errors = {}
    for field in ['id', 'mail', "fullname"]:
        if field not in shib_attrs:
            errors[field] = ("Required field '%s' can't be found." %
                             ShibbolethAttrMap.get_attr(field))

    if errors:
        LOG.error("The AAF IdP is not returning the required "
                  "attributes. The following are missing: %s. "
                  "The following are present: %s.",
                  ", ".join(errors.keys()), shib_attrs)
        error_values = list(errors.values())
        error_values.sort()
        data = {
            "title": "Error",
            "message": "Not enough details have been received from your "
                       "institution to allow you to log on to the cloud. "
                       "We need your id, your e-mail and your full name."
                       "<br />Please contact your institution and tell them "
                       "that their \"AAF IdP\" is broken!"
                       "<br />Copy and paste the details below into your "
                       "email to your institution's support desk."
                       "<br /><b>The following required fields are missing "
                       "from the AAF service:</b>",
            "errors": error_values}
        return template("error", **data)

    if request.forms.get("csrfmiddlewaretoken", ""):
        session["csrfmiddlewaretoken"] = \
          request.forms.get("csrfmiddlewaretoken")
        session.save()

    shib_user = db.query(models.User).filter_by(
        persistent_id=shib_attrs["id"]).first()
    if not shib_user:
        shib_user = models.create_shibboleth_user(db, shib_attrs)

    session["user_id"] = shib_attrs["id"]
    session.save()

    current_terms_version = CONFIG.get('terms_version', 'v1')

    if request.forms.get("agree") and shib_user.state == "new":
        date_now = datetime.now()
        shib_user.registered_at = date_now
        shib_user.terms_accepted_at = date_now
        shib_user.state = "registered"
        shib_user.terms_version = current_terms_version
        models.update_shibboleth_user(db, shib_user, shib_attrs)
        db.commit()

        # after registering present the user with a page indicating
        # there account is being created
        models.notify_account_creation(rpcclient, shib_attrs)

    if request.forms.get("agree") and shib_user.state == "created":
        # New terms version accepted
        shib_user.terms_version = current_terms_version
        shib_user.terms_accepted_at = datetime.now()
        models.update_shibboleth_user(db, shib_user, shib_attrs)
        db.commit()

    if request.forms.get("ignore_username"):
        # Ignore different username
        shib_user.ignore_username_not_email = True
        db.commit()

    if shib_user.terms_version != current_terms_version:
        data = {"title": "Terms and Conditions.",
                "terms_version": current_terms_version,
                "updated_terms": shib_user.terms_version}
        return template("terms_form", **data)

    if shib_user.state == "registered":
        data = {"title": "Creating Account...",
                "support_url": CONFIG["support_url"]}
        return template("creating_account", **data)

    if shib_user.state == "created":
        set_username_as_email = False

        if request.forms.get("change_username"):
            # User wants to change their username to match email
            set_username_as_email = True

        try:
            token, project_id, user = models.keystone_authenticate(
                shib_user.user_id, email=shib_user.email,
                full_name=shib_user.displayname,
                set_username_as_email=set_username_as_email)
        except Exception as e:
            # TODO(russell) the error handing this exception is
            # to broad.

            # Martin: the error is occurring because Keystone has no
            # knowledge of the user, but we (fakeshib) do...  Which
            # raises an interesting philosophical question - how did
            # we get into this state?  BTW, if the user is in this
            # state, he has lost everything in the cloud, and is
            # likely to be unhappy...
            LOG.exception("A user known to rcshibboleth isn't known by "
                          "Keystone! Their user id is: %s", shib_user.user_id)
            data = {
                "title": "Error",
                "message": 'Your details could not be found on the '
                           'central authentication server. '
                           'Thus you will <b><i>not</i></b> be able to '
                           'access the cloud! <br />Please contact <a '
                           'href="' + CONFIG["support_url"] + '">support</a> '
                           'to resolve this issue.'
                           '<br />The error message is:',
                "errors": [str(e)]}

            # We should perhaps redirect the user to a nicer more
            # useful error page...
            return template("error", **data)

    models.update_shibboleth_user(db, shib_user, shib_attrs)

    if user.name != user.email and not shib_user.ignore_username_not_email:
        data = {"user": user}
        return template("username_form", **data)

    # sjjf: default to the configured target URL, but allow the source
    # to specify a different return-path. The specified return path is
    # then verfied against a white list.
    target = CONFIG["target"]
    if "return-path" in request.query:
        t = request.query["return-path"]
        whitelist = Whitelist()
        url_pieces = parse.urlparse(t)
        url_match = "{}://{}{}".format(url_pieces.scheme, url_pieces.netloc,
                                       url_pieces.path)
        if url_match in whitelist:
            target = t
        else:
            LOG.exception("Attempt to authenticate to a blocked URL: %s", t)
            data = {
                "title": "Authentication Error",
                "message": "You attempted to authenticate to the "
                + t
                + " URL, which is not permitted by this service."
                }
            return template("error", **data)

    data = {"token": token,
            "tenant_id": project_id,
            "target": target}
    models.notify_login(rpcclient, shib_user, user)
    return template("redirect", **data)


@route('/terms.html')
def terms(db):
    return template("terms.html")


def error_template(head_html, exception, extra):
    from rcshibboleth.wsgiapp import support_url
    data = {
        "title": "Error",
        "message": "An internal error has occurred and has been logged by "
        "our system.  Our system administrators have been notified."
        "If you have been receiving this message often then "
        'please contact <a href="' + support_url
        + '">support</a> for assistance.'}
    return template("error", **data)
